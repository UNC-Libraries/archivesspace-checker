<?xml version="1.0" encoding="UTF-8"?>
<schema xmlns="http://purl.oclc.org/dsdl/schematron" queryBinding="xslt2">
  <ns uri="http://www.w3.org/1999/xlink" prefix="xlink"/>
  <ns uri="urn:isbn:1-931666-22-9" prefix="ead"/>

  <phase id="manual">
    <active pattern="descgrp-manual" />
    <active pattern="ead-id-attr-manual" />
    <active pattern="did-manual" />
    <active pattern="table-manual" />
    <active pattern="daodesc-manual" />
    <active pattern="daoloc-manual" />
    <active pattern="change-manual" />
    <active pattern="controlaccess-manual" />
    <active pattern="date-unitdate-manual" />
    <active pattern="date-type-manual" />
    <active pattern="container-manual" />
    <active pattern="any-manual" />
    <active pattern="unitid-manual" />
    <active pattern="unittitle-manual" />
<!-- <active pattern="daogrp-manual" /> Error will be fixed on ingest LDF 2-2-21 -->
    <active pattern="namegrp-manual" />
    <active pattern="name-manual" />
    <active pattern="identifier-manual" />
    <active pattern="bibliography-manual" />
    <active pattern="ptrgrp-manual" />
    <active pattern="nested-list-manual" />
    <active pattern="abstract-manual" />
    <active pattern="component-manual" />
    <active pattern="extref-manual" />
    <active pattern="digcontainer-manual" />
    <active pattern="containerized-extref-manual" />
    <active pattern="migrating-noncontainerized-extref-manual" />
    <active pattern="langcode-manual" />
  </phase>

  <pattern id="descgrp-manual">
    <rule context="//*:descgrp[(@type and @type != 'add') or (not(normalize-space(@type)) and @encodinganalog = '544')]/*:address|
                   //*:descgrp[(@type and @type != 'add') or (not(normalize-space(@type)) and @encodinganalog = '544')]/*:blockquote|
                   //*:descgrp[(@type and @type != 'add') or (not(normalize-space(@type)) and @encodinganalog = '544')]/*:chronlist|
                   //*:descgrp[(@type and @type != 'add') or (not(normalize-space(@type)) and @encodinganalog = '544')]/*:list|
                   //*:descgrp[(@type and @type != 'add') or (not(normalize-space(@type)) and @encodinganalog = '544')]/*:p">
      <!-- 'descgrp' sub-elements of kinds valid in 'note' element -->
      <assert test="not(.)" diagnostics="da-2">'descgrp' is deprecated, and must be removed. 'address', 'blockquote', 'chronlist', 'list', and 'p' children of 'descgrp' must be reparented into a new 'note' element in the 'descgrp's parent element</assert>
    </rule>

    <rule context="//*:descgrp[@type]">
      <!-- 'descgrp' elements with type 'add' -->
      <assert test="not(@type='add')" diagnostics="dm-1">'descgrp' is deprecated, and must be removed. 'descgrp' element with type 'add' requires manual review and intervention.</assert>
    </rule>
  </pattern>

  <pattern id="ead-id-attr-manual">
    <rule context="/*:ead">
    <!-- 'id' attribute of root ead element-->
    <assert test="@id = ('ncc', 'nccpa', 'nccu', 'nccu-offsite', 'rbc', 'sfc', 'shc', 'ua', 'ulgac')" diagnostics="ead-id-attr">
        '<value-of select="@id" />' is blank or an unrecognized repo/collecting-unit code
    </assert>
    </rule>
  </pattern>

  <pattern id="did-manual">

    <rule context="/*:ead/*:archdesc/*:did">
      <!-- 'did' element (collection-level) -->
      <assert test=".[*:unittitle]" diagnostics="didm-2">
        Collection level 'did' element must contain a 'unittitle' element.
      </assert>

      <assert test=".[*:unitdate or *:unittitle/*:unitdate]" diagnostics="didm-3">
        Collection level 'did' element must contain a 'unitdate' element.
      </assert>

      <!-- date values are carried either in a text node or a 'normal' attribute-->
      <assert test="*:unitdate/descendant-or-self::*/text()[normalize-space(.)] or
                    *:unittitle/*:unitdate/descendant-or-self::*/text()[normalize-space(.)] or
                    *:unitdate/@normal or
                    *:unittitle/*:unitdate/@normal" diagnostics="didm-3a">
        Collection level 'did' elements must contain a 'unitdate' element with text or a 'normal' attribute.
      </assert>

      <assert test=".[*:physdesc/*:extent] or (.[*:physdesc] and lower-case(./*:physdesc/@label) = 'extent')"
              diagnostics="didm-5">
        Collection level 'did' element must contain 'physdesc' element with 'extent' child or text.
      </assert>

      <assert test=".[not(*:container)]" diagnostics="didm-6">
        Collection level 'did' element must not contain 'container' element.
      </assert>

    </rule>

    <rule context="/*:ead/*:archdesc/*[not(local-name(.) = 'did')]//*:did">
      <!-- 'did' elements (anywhere below collection-level)-->
      <assert test=".[*:unitdate or *:unittitle/*:unitdate] or (.[*:unittitle] and ./*:unittitle/descendant-or-self::*/text()[normalize-space(.)])" diagnostics="didm-4">
        'did' elements must contain a either a 'unitdate' element, a non-empty 'unittitle' element or both.
      </assert>

      <assert test="*:unittitle/descendant-or-self::*/text()[normalize-space(.)]" diagnostics="date-title">
        <!-- Aspace will accept either a unittitle or unitdate here, but per AS-350 we are
             requiring a unittitle -->
        'did' elements must contain a unittitle that contains text (or a descendant that contains text)
      </assert>
    </rule>

    <rule context="/*:ead/*:archdesc/*:did/*:unittitle">
      <!-- 'unittitle' element (collection-level) -->
      <assert test="./text()[normalize-space(.)]" diagnostics="didm-2a">
        Collection level 'unittitle' element must not be empty.
      </assert>
    </rule>

    <!--  Doesn't verify <extent> parsability if <extent> isn't first child extent of parent <physdesc> (and first child has text)  -->
    <rule context="/*:ead/*:archdesc/*:did/*:physdesc/*:extent">
      <!-- 'physdesc/extent' element (collection-level) -->
      <assert test="./text()[normalize-space(.)]
                    and ((not(./ancestor::*/physdesc/*:extent[1] = .) and normalize-space(string-join(./ancestor::*/physdesc/*:extent[1]/text(), '')))
                         or matches(normalize-space(.), '^\s*\(?((About|Approximately|circa|Ca\.|Around)\s+)?([0-9\.,]+)+\s+([^,;]*)$')
                         or (.[@unit] and matches(normalize-space(.), concat('^\s*\(?((About|Approximately|circa|Ca\.|Around)\s+)?(', ./@unit, ':\s+)?([0-9\.,]+)+$'), 'i')))"
              diagnostics="didm-5a">
        'extent' element content is in unsupported format.
      </assert>
    </rule>

    <rule context="/*:ead/*:archdesc/*:did/*:physdesc">
      <!-- 'physdesc' element (collection-level) -->
      <assert test=".[*:extent]
                    or (lower-case(./@label) = 'extent'
                        and matches(normalize-space(.), '^\s*\(?((About|Approximately|circa|Ca\.|Around)\s+)?([0-9\.,]+)+\s+([^,;]*)$'))"
              diagnostics="didm-5b">
        'physdesc' element content is in unsupported format for extent.
      </assert>
    </rule>

  </pattern>

  <pattern id="table-manual">
    <rule context="//*:table">
      <!-- 'table' element -->
      <assert test="not(.)" diagnostics="tblm-1">
        'table' element is deprecated and must be removed.
      </assert>
    </rule>
  </pattern>

  <pattern id="date-unitdate-manual">
    <rule context="//*:date|//*:unitdate">
      <!-- 'date' and 'unitdate' elements -->
      <assert test="not(.[@startYear or @endYear])" diagnostics="dua-1">
        'date' and 'unitdate' elements must not contain 'startYear' or 'endYear' attributes.
      </assert>

      <assert test="(not(.[node()]) and count(./@era|@calendar|@type) = count(./@*)) or matches(normalize-space(tokenize(./@normal, '/')[1]), '^([0-9]{4}(\-(1[0-2]|0[1-9])(\-(0[1-9]|[12][0-9]|3[01]))?)?)$') or normalize-space(string-join((./@startYear, ./@endYear, ./text()), ''))" diagnostics="noempty-2">
        'date' and 'unitdate' elements must contain a valid value in either or both of their 'normal' attribute or their text content.
      </assert>

      <assert test="not(.[@startYear or @endYear or @normal]) or not(.[@startYear gt @endYear] or .[tokenize(@normal, '/')[1] gt tokenize(@normal, '/')[2]])" diagnostics="dua-3">
        'date' and 'unitdate' elements must not have ending dates previous to their start dates.
      </assert>
    </rule>

  </pattern>

  <pattern id="date-type-manual">
      <rule context="/*:ead/*:archdesc/*[not(local-name(.) = 'did')]//*:did//*:unitdate[@type]">
      <!-- unitdate elements in 'did' elements anywhere below collection-level-->

      <!-- Note: Allowed date-type for 'date' elements differ from those allowed
           for 'unitdate' elements. For example, 'date' elements allow 'span'.
      -->
      <!-- This rule won't detect extra whitespace in the type. For example,
           it will NOT detect a unitdate like:
            <unitdate type="inclusive ">
           It may be possible to detect the whitespace, but in the ways I've tried
           to test, the attribute value seems to already have been normalized.
      -->
      <assert test="@type = ('bulk', 'inclusive', 'range', 'single')" diagnostics="date-type">
        '<value-of select="@type" />' is not an allowed date type. 'did' date types must be one of: bulk, inclusive, range, single
      </assert>
    </rule>
  </pattern>


  <pattern id="container-manual">
    <rule context="//*:container">
      <!-- 'container' element -->
      <assert test="(./descendant-or-self::*/text()[normalize-space(.)] and .[@type]) or (not(./descendant-or-self::*/text()[normalize-space(.)]) and not(.[@type]))" diagnostics="ca-1">
        'container' element must have content and contain 'type' attribute.
      </assert>
    </rule>
  </pattern>

  <pattern id="daodesc-manual">
    <rule context="//*:daodesc">
      <!-- 'daodesc' element -->
      <assert test="./ancestor::*/dao or ./ancestor::*/daogrp" diagnostics="daodesc-1">
        'daodesc' element found.
      </assert>
    </rule>
  </pattern>

  <pattern id="daoloc-manual">
    <rule context="//*:daoloc">
      <!-- 'daoloc' element -->
      <assert test="./ancestor::*/dao or ./ancestor::*/daogrp" diagnostics="daoloc-1">
        'daoloc' element found.
      </assert>
    </rule>
  </pattern>

  <pattern id="any-manual">
    <rule context="//*[not(@*)]">
      <!-- Any element ('//*') -->
      <assert test="local-name(.) = 'physdesc' or ./text()[normalize-space(.)] or not(./*) or count(./*:p|./*:lb|./*:head) = count(./*) or ./*[@*] or ./*/text()[normalize-space(.)] or ./*/*" diagnostics="noempty-1">
        Any element must contain either text or attribute content or have nested elements with text, element, or attribute content.
      </assert>
    </rule>
  </pattern>

  <pattern id="unitid-manual">
    <rule context="//*:did[count(./*:unitid) gt 1]">
      <!-- 'unitid' element -->
      <assert test="not(.)" diagnostics="unitid-1">
        More than one 'unitid' element may not be provided per level of description ('did' element), per ArchivesSpace.  One authoritative 'unitid' element should be decided on or created, method of choice/construction is left to local practice to determine.
      </assert>
    </rule>

    <rule context="//*:unitid">
      <!-- 'unitid' elements pointed at by 'ref' elements -->
      <assert test="not(./@id = //*:ref/@target)" diagnostics="unitid-2">
        'ref' elements must not point at 'unitid' elements.  'target' attribute should be rewritten to point at parent 'c'.
      </assert>
    </rule>

    <rule context="/*:ead">
      <!-- 'unitid' element (collection-level) -->
      <assert test="not(./*:archdesc/*:did/*:unitid/text()) or (replace(lower-case(normalize-space(./*:archdesc/*:did/*:unitid/text())), '\s+|^0+|-z$', '') =
                    replace(lower-case(normalize-space(//*:eadid/text())), '\s+|^0+|-z$', ''))"
              diagnostics="unitid-3">
        Collection level 'unitid' element must equal 'eadid'.
      </assert>
    </rule>
  </pattern>

  <pattern id="unittitle-manual">
    <rule context="//*:did[count(./*:unittitle) gt 1]">
      <!-- 'unittitle' element -->
      <assert test="not(.)" diagnostics="unittitle-1">
        More than one 'unittitle' element may not be provided per level of description ('did' element), per ArchivesSpace.  One authoritative 'unittitle' element should be decided on or created, method of choice/construction is left to local practice to determine.
      </assert>
    </rule>

    <rule context="//*:unittitle">
      <!-- 'unittitle' elements -->
      <assert test="not(./@id = //*:ref/@target)" diagnostics="unittitle-2">
        'ref' elements must not point at 'unittitle' elements.  'target' attribute should be rewritten to point at parent 'c'.
      </assert>
    </rule>
  </pattern>

  <!-- Error will be fixed on ingest LDF 2-2-21 -->
 <!-- <pattern id="daogrp-manual">
    <rule context="//*:daogrp">
      &lt;!&ndash; 'daogrp' element &ndash;&gt;
      <assert test="not(.)" diagnostics="daogrp-1">
        'daogrp' element is not well supported in ArchivesSpace.  Remove 'daogrp', and rewrite contained 'daoloc' elements to 'dao's, taking xlink attributes from 'arc' elements.
      </assert>
    </rule>
  </pattern>-->
  <pattern id="namegrp-manual">
    <rule context="//*:namegrp">
      <!-- 'namegrp' element -->
      <assert test="not(.)" diagnostics="namegrp-1">
        'namegrp' element is not supported in ArchivesSpace. Serialize contents of 'namegrp' subelements in content of first subelement, and replace 'namegrp' with first subelement.
      </assert>
    </rule>
  </pattern>

  <pattern id="identifier-manual">
    <rule context="/*:ead">
      <!-- 'ead' element -->
      <assert test="not(.[.//*:eadid/@identifier]) or
                    (./*:archdesc//*:processinfo/*:p/text() = .//*:eadid/@identifier)"
              diagnostics="identifier-1">
        The 'identifier' attribute on 'eadid' elements is not preserved by ArchivesSpace.  Place contents in a 'p' element within a 'processinfo' element in 'archdesc'.
      </assert>
    </rule>
  </pattern>

  <pattern id="bibliography-manual">
    <rule context="//*:bibliography/*:list">
      <!-- 'bibliography' element -->
      <assert test="not(.)" diagnostics="bibliography-1">
        'bibliography' element with 'list' element as content imports incorrectly.  Change 'item' elements to 'bibref' elements, move into parent 'bibliography', drop 'list'.
      </assert>
    </rule>
  </pattern>

  <pattern id="change-manual">
    <rule context="//*:revisiondesc/*:change">
      <!-- 'change' element in 'revisiondesc' -->
      <assert test=".[*:date and *:item]" diagnostics="change-1">
        'revisiondesc/change' element must contain both a date and an item subelement.
      </assert>

      <!-- Unsure whether Aspace requires both date and item subelements must
        contain text or if at least one must contain text. Regardless, this test
        requires both to contain text.
       -->
      <assert test="*:date/text()[normalize-space(.)] and ./*:item/text()[normalize-space(.)]" diagnostics="change-2">
        'revisiondesc/change' date and item subelements must contain text
      </assert>
    </rule>
  </pattern>

  <pattern id="name-manual">
    <rule context="//*:name">
      <!-- 'name' element -->
      <assert test=".[not(@encodinganalog = ('110', '111', '130', '240', '245', '610', '611', '630', '650', '651', '654', '700', '710'))]" diagnostics="name-1">
        'name' elements with 'encodinganalog' attribute values that correspond to more specific EAD elements should be represented by those elements instead of 'name'.
      </assert>
    </rule>
  </pattern>

  <pattern id="ptrgrp-manual">
    <rule context="//*:ptrgrp">
      <!-- 'ptrgrp' element -->
      <assert test="not(.)" diagnostics="ptrgrp-1">
        'ptrgrp' elements with nested 'ref' elements are not properly imported by ArchivesSpace. The 'ptrgrp' should be replaced with a 'ref' element and the 'ref's to nested 'ptr's.
      </assert>
    </rule>
  </pattern>

  <pattern id="nested-list-manual">
    <rule context="//*:list">
      <!-- 'list' element -->
      <assert test="not(./ancestor::*/item)" diagnostics="nested-list-1">
        'item' elements with 'list' element children are not properly imported by ArchivesSpace.  'list' elements should be flattened so that no nesting occurs.
      </assert>
    </rule>
  </pattern>

  <pattern id="controlaccess-manual">
    <rule context="//*:controlaccess">
      <!-- 'controlaccess' element -->
      <assert test="count(./*:corpname|./*:persname|./*:famname|./*:function|./*:genreform|./*:geogname|./*:occupation|./*:subject|./*:title|./*:list|./*:head) = count(./*)
                    and count(./*:list/*:item/*:corpname|./*:list/*:item/*:persname|./*:list/*:item/*:famname|
                    ./*:list/*:item/*:function|./*:list/*:item/*:genreform|./*:list/*:item/*:geogname|
                    ./*:list/*:item/*:occupation|./*:list/*:item/*:subject|./*:list/*:item/*:title) = count(./*:list/*:item/*)"
              diagnostics="controlaccess-1">
        The only 'controlaccess' children that will migrate are: 'corpname', 'persname', 'famname', 'function', 'genreform', 'geogname', 'occupation', 'subject', 'title'.
      </assert>
    </rule>

    <rule context="//*:item/*:corpname|//*:item/*:persname|//*:item/*:famname|
                   //*:item/*:function|//*:item/*:genreform|//*:item/*:geogname|
                   //*:item/*:occupation|//*:item/*:subject|
                   //*:item/*:title">
      <!-- 'controlaccess' children (that are migrating/valid)-->

      <!-- NOTE: we allow 'title' in lists outside of 'controlaccess' -->
      <assert test="./ancestor::controlaccess or local-name(.) = 'title'" diagnostics="controlaccess-2">
        Lists containing 'corpname', 'persname', 'famname', 'function', 'genreform', 'geogname', 'occupation', or 'subject' elements can only be parsed as children of 'controlaccess' elements.
      </assert>

      <assert test="text()[normalize-space(.)]" diagnostics="controlaccess-3">
        'controlaccess' children must contain text
      </assert>
    </rule>
  </pattern>

  <pattern id="abstract-manual">
    <rule context="//*:abstract">
    <!-- 'abstract' elements -->
      <assert test="text()[normalize-space(.)]" diagnostics="abstract">
        'abstract' elements must contain text
      </assert>
    </rule>
  </pattern>

  <pattern id="component-manual">
    <rule context="//*:c|//*:c01|//*:c02|//*:c03|//*:c04|//*:c05|//*:c06|//*:c07|//*:c08|//*:c09|//*:c10|//*:c11|//*:c12">
    <!-- 'component' elements, any numbered or unnumbered -->
      <assert test="not(@id)" diagnostics="component-id">
        'component' elements must not contain an 'id' attribute (because Aspace would import it as a ref_id)
      </assert>
    </rule>
  </pattern>

  <pattern id="extref-manual">
    <rule context="//did/container//extref|//*:c/did//unittitle//extref|//*:c01/did//unittitle//extref|//*:c02/did//unittitle//extref|//*:c03/did//unittitle//extref|//*:c04/did//unittitle//extref|//*:c05/did//unittitle//extref|//*:c06/did//unittitle//extref|//*:c07/did//unittitle//extref|//*:c08/did//unittitle//extref|//*:c09/did//unittitle//extref|//*:c10/did//unittitle//extref|//*:c11/did//unittitle//extref|//*:c12/did//unittitle//extref">
      <!-- 'extref' elements that are migrating, i.e. fall under one of:
              - //c0x/did/container//extref
              - //c0x/did//unittitle//extref
            Note we do not need to specify the c0x in the container context xpath
            because another rule already ensures no containers in a collection
            level 'did'
      -->
      <assert test="@href and not(@href = '')" diagnostics="extref-href">
        migrating 'extref' elements must have a non-empty href attribute
      </assert>
    </rule>
  </pattern>

  <pattern id="digcontainer-manual">
    <rule context="//*:container[@type = 'digfolder' or @type = 'digitem']">
      <!-- 'container' element of type digfolder/digitem -->
      <!-- other container types MAY contain migrating extrefs but only
           digfolder/digitem container MUST contain an extref-->
      <assert test=".//extref" diagnostics="digcontainer-extref">
        'container' elements of type digfolder/digitem must contain an 'extref' element.
      </assert>
    </rule>
  </pattern>

  <pattern id="containerized-extref-manual">
    <rule context="//did/container[descendant::extref]">
      <!-- any 'container' element with an extref-->
      <!-- We want this to report any text that does not match ruby's /^\s*(DF|DI|etc)-\S+\s*$/
           but it seems like XSLT flavor of regexp \s does not include tab -->
      <assert test="matches(.//extref, '^[\s&#x9;]*(DF|DI|DCD|FLD|EKAAMP)-\S*[\s&#x9;]*$')" diagnostics="containerized-extref-identifiers">
        containerized extrefs must contain DF/DI identifier text. Found: '<value-of select="normalize-space(.//extref)" />'
      </assert>
    </rule>
  </pattern>

  <pattern id="migrating-noncontainerized-extref-manual">
    <rule context="//*:c/did//unittitle//extref|//*:c01/did//unittitle//extref|//*:c02/did//unittitle//extref|//*:c03/did//unittitle//extref|//*:c04/did//unittitle//extref|//*:c05/did//unittitle//extref|//*:c06/did//unittitle//extref|//*:c07/did//unittitle//extref|//*:c08/did//unittitle//extref|//*:c09/did//unittitle//extref|//*:c10/did//unittitle//extref|//*:c11/did//unittitle//extref|//*:c12/did//unittitle//extref">
      <!-- migrating noncontainzerized 'extref' elements -->
      <assert test="not(matches(., '^[\s&#x9;]*[A-Z]+-\S*[\s&#x9;]*$'))" diagnostics="noncontainerized-extref-dfdi-identifiers">
        noncontainerized migrating extrefs should not have DF/DI identifier-like text:  Found: '<value-of select="normalize-space(.)" />'
      </assert>
    </rule>
  </pattern>

  <pattern id="langcode-manual">
      <rule context="//*:language[@langcode]">
      <!-- 'langcode' attribute of any language element-->
      <assert test="@langcode = ('eng', 'aar', 'abk', 'ace', 'ach', 'ada', 'ady', 'afa', 'afh',
        'afr', 'ain', 'aka', 'akk', 'alb', 'ale', 'alg', 'alt', 'amh', 'ang', 'anp', 'apa', 'ara',
        'arc', 'arg', 'arm', 'arn', 'arp', 'art', 'arw', 'asm', 'ast', 'ath', 'aus', 'ava', 'ave',
        'awa', 'aym', 'aze', 'bad', 'bai', 'bak', 'bal', 'bam', 'ban', 'baq', 'bas', 'bat', 'bej',
        'bel', 'bem', 'ben', 'ber', 'bho', 'bih', 'bik', 'bin', 'bis', 'bla', 'bnt', 'bos', 'bra',
        'bre', 'btk', 'bua', 'bug', 'bul', 'bur', 'byn', 'cad', 'cai', 'car', 'cat', 'cau', 'ceb',
        'cel', 'cha', 'chb', 'che', 'chg', 'chi', 'chk', 'chm', 'chn', 'cho', 'chp', 'chr', 'chu',
        'chv', 'chy', 'cmc', 'cop', 'cor', 'cos', 'cpe', 'cpf', 'cpp', 'cre', 'crh', 'crp', 'csb',
        'cus', 'cze', 'dak', 'dan', 'dar', 'day', 'del', 'den', 'dgr', 'din', 'div', 'doi', 'dra',
        'dsb', 'dua', 'dum', 'dut', 'dyu', 'dzo', 'efi', 'egy', 'eka', 'elx', 'eng', 'enm', 'epo',
        'est', 'ewe', 'ewo', 'fan', 'fao', 'fat', 'fij', 'fil', 'fin', 'fiu', 'fon', 'fre', 'frm',
        'fro', 'frr', 'frs', 'fry', 'ful', 'fur', 'gaa', 'gay', 'gba', 'gem', 'geo', 'ger', 'gez',
        'gil', 'gla', 'gle', 'glg', 'glv', 'gmh', 'goh', 'gon', 'gor', 'got', 'grb', 'grc', 'gre',
        'grn', 'gsw', 'guj', 'gwi', 'hai', 'hat', 'hau', 'haw', 'heb', 'her', 'hil', 'him', 'hin',
        'hit', 'hmn', 'hmo', 'hrv', 'hsb', 'hun', 'hup', 'iba', 'ibo', 'ice', 'ido', 'iii', 'ijo',
        'iku', 'ile', 'ilo', 'ina', 'inc', 'ind', 'ine', 'inh', 'ipk', 'ira', 'iro', 'ita', 'jav',
        'jbo', 'jpn', 'jpr', 'jrb', 'kaa', 'kab', 'kac', 'kal', 'kam', 'kan', 'kar', 'kas', 'kau',
        'kaw', 'kaz', 'kbd', 'kha', 'khi', 'khm', 'kho', 'kik', 'kin', 'kir', 'kmb', 'kok', 'kom',
        'kon', 'kor', 'kos', 'kpe', 'krc', 'krl', 'kro', 'kru', 'kua', 'kum', 'kur', 'kut', 'lad',
        'lah', 'lam', 'lao', 'lat', 'lav', 'lez', 'lim', 'lin', 'lit', 'lol', 'loz', 'ltz', 'lua',
        'lub', 'lug', 'lui', 'lun', 'luo', 'lus', 'mac', 'mad', 'mag', 'mah', 'mai', 'mak', 'mal',
        'man', 'mao', 'map', 'mar', 'mas', 'may', 'mdf', 'mdr', 'men', 'mga', 'mic', 'min', 'mis',
        'mkh', 'mlg', 'mlt', 'mnc', 'mni', 'mno', 'moh', 'mon', 'mos', 'mul', 'mun', 'mus', 'mwl',
        'mwr', 'myn', 'myv', 'nah', 'nai', 'nap', 'nau', 'nav', 'nbl', 'nde', 'ndo', 'nds', 'nep',
        'new', 'nia', 'nic', 'niu', 'nno', 'nob', 'nog', 'non', 'nor', 'nqo', 'nso', 'nub', 'nwc',
        'nya', 'nym', 'nyn', 'nyo', 'nzi', 'oci', 'oji', 'ori', 'orm', 'osa', 'oss', 'ota', 'oto',
        'paa', 'pag', 'pal', 'pam', 'pan', 'pap', 'pau', 'peo', 'per', 'phi', 'phn', 'pli', 'pol',
        'pon', 'por', 'pra', 'pro', 'pus', 'que', 'raj', 'rap', 'rar', 'roa', 'roh', 'rom', 'rum',
        'run', 'rup', 'rus', 'sad', 'sag', 'sah', 'sai', 'sal', 'sam', 'san', 'sas', 'sat', 'scn',
        'sco', 'sel', 'sem', 'sga', 'sgn', 'shn', 'sid', 'sin', 'sio', 'sit', 'sla', 'slo', 'slv',
        'sma', 'sme', 'smi', 'smj', 'smn', 'smo', 'sms', 'sna', 'snd', 'snk', 'sog', 'som', 'son',
        'sot', 'spa', 'srd', 'srn', 'srp', 'srr', 'ssa', 'ssw', 'suk', 'sun', 'sus', 'sux', 'swa',
        'swe', 'syc', 'syr', 'tah', 'tai', 'tam', 'tat', 'tel', 'tem', 'ter', 'tet', 'tgk', 'tgl',
        'tha', 'tib', 'tig', 'tir', 'tiv', 'tkl', 'tlh', 'tli', 'tmh', 'tog', 'ton', 'tpi', 'tsi',
        'tsn', 'tso', 'tuk', 'tum', 'tup', 'tur', 'tut', 'tvl', 'twi', 'tyv', 'udm', 'uga', 'uig',
        'ukr', 'umb', 'und', 'urd', 'uzb', 'vai', 'ven', 'vie', 'vol', 'vot', 'wak', 'wal', 'war',
        'was', 'wel', 'wen', 'wln', 'wol', 'xal', 'xho', 'yao', 'yap', 'yid', 'yor', 'ypk', 'zap',
        'zbl', 'zen', 'zha', 'znd', 'zul', 'zun', 'zxx', 'zza', 'cnr', 'zgh')"
      diagnostics="langcode">
        '<value-of select="@langcode" />' is not an allowed language code.
      </assert>
    </rule>
  </pattern>

  <diagnostics>
    <diagnostic id="dm-1">Ref-number: AS-38
      Content: [Shouldn't exist in UNC EAD]
    </diagnostic>
    <diagnostic id="da-2">Ref-number: AS-38
      Content: [Shouldn't exist in UNC EAD] '<value-of select="local-name(.)" />' element can be moved out of 'descgrp' element into a new 'note' element in surrounding '<value-of select="local-name(./../..)" />'</diagnostic>
    <diagnostic id="didm-2">Ref-number: AS-54</diagnostic>
    <diagnostic id="didm-2a">Ref-number: AS-54</diagnostic>
    <diagnostic id="didm-3">Ref-number: AS-54</diagnostic>
    <diagnostic id="didm-3a">Ref-number: AS-296</diagnostic>
    <diagnostic id="didm-5">Ref-number: AS-54</diagnostic>
    <diagnostic id="didm-5a">Ref-number: AS-60
      Content: Value is "<value-of select="." />" with unit attribute "<value-of select="./@unit" />"</diagnostic>
    <diagnostic id="didm-5b">Ref-number: AS-91
      Content: Value is "<value-of select="." />"</diagnostic>
    <diagnostic id="didm-6">Ref-number: AS-54
      Content: 'container' elements should not be nested within the 'did' in the 'archdesc'.
    </diagnostic>
    <diagnostic id="didm-4">Ref-number: AS-51</diagnostic>
    <diagnostic id="tblm-1">Ref-number: AS-38
      Content: [Shouldn't exist in UNC EAD]
    </diagnostic>
    <diagnostic id="dua-1">Ref-number: AS-38
      Content: [Shouldn't exist in UNC EAD] Content from '<value-of select="local-name(.)" />' element's 'startYear' (<value-of select="./@startYear" />) and 'endYear' (<value-of select="./@endYear" />) attributes should be combined into a single 'normal' attribute separated by '/' (<value-of select="./@startYear" />/<value-of select="./@endYear" />)
    </diagnostic>
    <diagnostic id="ca-1">Ref-number: AS-38</diagnostic>
    <diagnostic id="daodesc-1">Ref-number: AS-52</diagnostic>
    <diagnostic id="daoloc-1">Ref-number: AS-52</diagnostic>
    <diagnostic id="noempty-1">Ref-number: AS-38|APPDEV-9598
      Content: '<value-of select="local-name(.)" />' element should not have empty children
    </diagnostic>
    <diagnostic id="noempty-2">Ref-number: AS-38</diagnostic>
    <!--  Should be covered better by noempty-2: <diagnostic id="didm-3a">Ref-number: AS-38</diagnostic> -->
    <diagnostic id="dua-3">Ref-number: 57</diagnostic>
    <diagnostic id="unitid-1">Ref-number: AS-38
      Content: [Shouldn't exist in UNC EAD]
    </diagnostic>
    <diagnostic id="unitid-2">Ref-number: AS-38
      Content: [Shouldn't exist in UNC EAD]
    </diagnostic>
    <diagnostic id="unitid-3">Ref-number: AS-66</diagnostic>
    <diagnostic id="unittitle-1">Ref-number: AS-51</diagnostic>
    <diagnostic id="unittitle-2">Ref-number: AS-51
      Content: [Shouldn't exist in UNC EAD]
    </diagnostic>
    <diagnostic id="daogrp-1">Ref-number: AS-52</diagnostic>
    <!-- Not needed since daogrp-1 checks for any daogrp: <diagnostic id="daogrp-2">Ref-number: AS-52</diagnostic>  -->
    <diagnostic id="namegrp-1">Ref-number: AS-38
      Content: [Shouldn't exist in UNC EAD]
    </diagnostic>
    <diagnostic id="identifier-1">Ref-number: AS-38
      Content: [Shouldn't exist in UNC EAD]
    </diagnostic>
    <diagnostic id="bibliography-1">Ref-number: AS-38
      Content: [Shouldn't exist in UNC EAD]
    </diagnostic>
    <diagnostic id="change-1">Ref-number: AS-38
      Content: [Shouldn't exist in UNC EAD]
    </diagnostic>
    <diagnostic id="change-2">Ref-number: AS-243</diagnostic>
    <diagnostic id="name-1">Ref-number: AS-38
      Content: encodinganalog value is '<value-of select="./@encodinganalog" />', local practice at Harvard is to represent values according to the following mappings: 110,111,710=corpname, 130,240,245=title, 610,611,630,650,654=subject, 651=geogname, 700=persname</diagnostic>
    <diagnostic id="ptrgrp-1">Ref-number: AS-38
      Content: [Shouldn't exist in UNC EAD]
    </diagnostic>
    <diagnostic id="nested-list-1">Ref-number: AS-55</diagnostic>
    <diagnostic id="controlaccess-1">Ref-number: AS-49</diagnostic>
    <diagnostic id="controlaccess-2">Ref-number: AS-98</diagnostic>
    <diagnostic id="controlaccess-3">Ref-number: AS-243</diagnostic>
    <diagnostic id="abstract">Ref-number: AS-243</diagnostic>
    <diagnostic id="component-id">Ref-number: AS-236</diagnostic>
    <diagnostic id="date-type">Ref-number: AS-243</diagnostic>
    <diagnostic id="date-title">Ref-number: AS-350/AS-243</diagnostic>
    <diagnostic id="langcode">Ref-number: AS-243</diagnostic>
    <diagnostic id="extref-href">Ref-number: AS-317, AS-358</diagnostic>
    <diagnostic id="digcontainer-extref">Ref-number: AS-352</diagnostic>
    <diagnostic id="containerized-extref-identifiers">Ref-number: AS-XXX/AS-353 TODO/TBD</diagnostic>
    <diagnostic id="noncontainerized-extref-dfdi-identifiers">Ref-number: AS-XXX/AS-353 TODO/TBD</diagnostic>
    <diagnostic id="ead-id-attr">Ref-number: AS-329</diagnostic>

    <!--  Logic seems wrong and duplicative?:  -->
    <!--    <diagnostic id="note-1">Ref-number: AS-38</diagnostic>  -->
    <!--    <diagnostic id="nested-list-2">Ref-number: AS-55</diagnostic>  -->
    <!--    <diagnostic id="enm-1">Ref-number: AS-60  -->
    <!--      Content: Value is "<value-of select="." />"</diagnostic>  -->

    <!--  Possibly outdated?:  -->
    <!--    'head' element seems to be ignored now.  -->
    <!--      <diagnostic id="da-1">Ref-number: AS-38</diagnostic>  -->
    <!--    Seems to handle archdesc/note now.  -->
    <!--      <diagnostic id="note-2">Ref-number: AS-38</diagnostic>  -->
    <!--      <diagnostic id="note-3">Ref-number: AS-38</diagnostic>  -->
    <!--      <diagnostic id="note-4">Ref-number: AS-38</diagnostic>  -->
    <!--    Seems to handle nested elements fine now.  -->
    <!--      <diagnostic id="da-3">Ref-number: AS-38  -->
    <!--        Content: '<value-of select="local-name(.)" />' element can be moved out of 'descgrp element into surrounding '<value-of select="local-name(./../..)" />'</diagnostic>  -->

    <!--  Fine:  -->
    <!--    We're okay with using default mixed_media instance type -->
    <!--      <diagnostic id="ca-2">Ref-number: AS-38</diagnostic>  -->
    <!--    We're okay with not populating unitdate certainty attribute  -->
    <!--      <diagnostic id="dua-2">Ref-number: AS-38</diagnostic>  -->

    <!--  Handled in UncEADConverter:  -->
    <!--    Missing unitid handled in UncEADConverter  -->
    <!--      <diagnostic id="didm-1">Ref-number: APPDEV-9598</diagnostic>  -->
    <!--      <diagnostic id="didm-1a">Ref-number: APPDEV-9598</diagnostic>  -->
    <!--    Missing otherlevel handled in UncEADConverter  -->
    <!--      <diagnostic id="c-1">Ref-number: APPDEV-9598</diagnostic>  -->
    <!--    Nested unitdate in unittitle handled in UncEADConverter  -->
    <!--      <diagnostic id="unittitle-3">Ref-number: AS-63</diagnostic>  -->
    <!--    Nested arrangement in scopecontent handled in UncEADConverter  -->
    <!--      <diagnostic id="scopecontent-1">Ref-number: APPDEV-9598</diagnostic>  -->
    <!--    dao ignored in UncEADConverter  -->
    <!--      <diagnostic id="dao-1">Ref-number: AS-92</diagnostic>  -->
  </diagnostics>

</schema>
